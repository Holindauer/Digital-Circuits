// sim_main.cpp
#include "Vcircuit_1.h"          // Generated by Verilator
#include "verilated.h"           // Verilator main header
#include "verilated_vcd_c.h"     // For VCD tracing
#include <iostream>

// Define the number of clock cycles you want to simulate
const int NUM_CLOCK_CYCLES = 6;

// Define time step (optional, for clarity)
const int TIME_STEP = 1;

int main(int argc, char** argv) {
    // Initialize Verilated with command line arguments
    Verilated::commandArgs(argc, argv);

    // Instantiate the Verilated model
    Vcircuit_1* tb = new Vcircuit_1;

    // Initialize input signals
    tb->clk = 0;
    tb->a = 0;
    tb->b = 0;

    // Initialize simulation time
    vluint64_t main_time = 0;

    // Total number of simulation steps (2 steps per clock cycle: rising and falling edge)
    const int TOTAL_STEPS = NUM_CLOCK_CYCLES * 2;

    // Initialize VCD tracing (optional, for waveform visualization)
    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    tb->trace(tfp, 99); // Trace 99 levels of hierarchy
    tfp->open("simulation.vcd"); // Output file

    // Simulation loop
    while (main_time < TOTAL_STEPS && !Verilated::gotFinish()) {
        // Determine the current clock cycle (0-based index)
        int current_cycle = main_time / 2;

        // Set 'a' and 'b' on the **falling edge** before the next rising edge
        if (!tb->clk) { // Falling edge
            switch (current_cycle) {
                case 0:
                    tb->a = 0;
                    tb->b = 0;
                    break;
                case 1:
                    tb->a = 1;
                    tb->b = 0;
                    break;
                case 2:
                    tb->a = 0;
                    tb->b = 1;
                    break;
                case 3:
                    tb->a = 1;
                    tb->b = 1;
                    break;
                case 4:
                    tb->a = 1;
                    tb->b = 0;
                    break;
                case 5:
                    tb->a = 0;
                    tb->b = 1;
                    break;
                default:
                    tb->a = 0;
                    tb->b = 0;
            }
        }

        // Toggle the clock
        tb->clk = !tb->clk;

        // Evaluate the model with the new clock value
        tb->eval();

        // Dump waveform data (optional)
        tfp->dump(main_time);

        // Print the current state
        std::cout << "Time " << main_time << ": "
                  << "clk=" << static_cast<int>(tb->clk) << ", "
                  << "a=" << static_cast<int>(tb->a) << ", "
                  << "b=" << static_cast<int>(tb->b) << ", "
                  << "y=" << static_cast<int>(tb->y) << std::endl;

        // Increment simulation time
        main_time += TIME_STEP;
    }

    // Finalize the simulation
    tb->final();
    tfp->close(); // Close the VCD file
    delete tfp;
    delete tb;

    return 0;
}
